```{r}
ev_data <- read.csv("../Dataset/pre-processed-EV-dataset.csv")
```

```{r}
# Aggregate data by County
ev_county <- ev_data %>%
  group_by(county) %>%
  summarise(EV_Count = n())

# Aggregate data by City
ev_city <- ev_data %>%
  group_by(city) %>%
  summarise(EV_Count = n())

# Aggregate data by Legislative District
ev_district <- ev_data %>%
  group_by(legislative_district) %>%
  summarise(EV_Count = n())
```

```{r}
ev_district
```

```{r}
library(dplyr)
library(ggplot2)

top_counties <- ev_clean %>%
  count(county, name = "EV_Count") %>%
  slice_max(EV_Count, n = 20)  # Select top 20 counties with highest EV count

ggplot(top_counties, aes(x = reorder(county, EV_Count), y = EV_Count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for better readability
  labs(title = "Top 20 Counties with Highest EV Adoption", x = "County", y = "EV Count") +
  theme_minimal()
```


```{r}
library(dplyr)
library(ggplot2)

top_cities <- ev_clean %>%
  count(city, name = "EV_Count") %>%
  slice_max(EV_Count, n = 20)  # Select top 20 cities with highest EV count

ggplot(top_cities, aes(x = reorder(city, EV_Count), y = EV_Count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for better readability
  labs(title = "Top 20 Cities with Highest EV Adoption", x = "City", y = "EV Count") +
  theme_minimal()
```

```{r}
library(dplyr)
library(ggplot2)

top_ld <- ev_clean %>%
  count(legislative_district, name = "EV_Count") %>%
  slice_max(EV_Count, n = 20)  # Select top 20 legislative_district with highest EV count

ggplot(top_ld, aes(x = reorder(legislative_district, EV_Count), y = EV_Count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for better readability
  labs(title = "Top 20 Cities with Highest EV Adoption", x = "City", y = "EV Count") +
  theme_minimal()
```


API key - c00131b3556a74bad78bbbb2d648afc4603bd046

```{r}
library(sf)
library(tidycensus)

# Get Washington State county geometries
census_api_key("c00131b3556a74bad78bbbb2d648afc4603bd046")  # Set your Census API key
county_shapes <- get_acs(
  geography = "county",
  variables = "B01001_001",  # Total population (for reference)
  state = "WA",
  geometry = TRUE
)

# Merge EV adoption data with county geometries
county_shapes <- county_shapes %>%
  left_join(ev_county, by = c("NAME" = "county"))

# Plot choropleth map
ggplot(county_shapes) +
  geom_sf(aes(fill = EV_Count)) +
  scale_fill_viridis_c(option = "plasma", na.value = "grey") +
  labs(title = "EV Adoption by County in Washington State", fill = "EV Count") +
  theme_minimal()

```


```{r}
# Install and load required packages
install.packages(c("tidycensus", "sf"))
library(tidycensus)
library(sf)

# Set your Census API key (replace <API-KEY> with your actual key)
census_api_key("c00131b3556a74bad78bbbb2d648afc4603bd046")

# Get city-level geometries for Washington State
city_shapes <- get_acs(
  geography = "place",  # 'place' refers to cities/towns
  variables = "B01001_001",  # Total population (for reference)
  state = "WA",  # Washington State
  year = 2020,  # ACS Year
  geometry = TRUE  # Include spatial geometries
)

# View the structure of city shapes
print(city_shapes)

# Plot city geometries (basic visualization)
plot(city_shapes["geometry"])

```


```{r}
library(dplyr)
library(ggplot2)

# # Example EV adoption data by city (replace with your actual dataset)
# ev_city <- data.frame(
#   City_Name = c("Seattle", "Tacoma", "Spokane"),
#   EV_Count = c(1500, 800, 600)
# )

# Merge EV adoption data with city geometries
city_shapes <- city_shapes %>%
  left_join(ev_city, by = c("NAME" = "city"))

# Plot choropleth map for cities
ggplot(city_shapes) +
  geom_sf(aes(fill = EV_Count)) +
  scale_fill_viridis_c(option = "magma", na.value = "grey") +
  labs(title = "EV Adoption by City in Washington State", fill = "EV Count") +
  theme_minimal()

```

```{r}
ev_data_modified <- ev_data %>%
  mutate(census_tract = as.character(census_tract))
```



T6: Analyze correlations between EV adoption and geographic factors
```{r}
library(tidyverse)
library(tidycensus)

# 1. Load and prepare demographic data
demographic_data <- get_acs(
  geography = "tract",
  variables = c(
    pop_density = "B01001_001",  # Total population (proxy for density)
    median_income = "B19013_001"  # Median household income
  ),
  state = "WA",
  year = 2020,
  geometry = FALSE,
  output = "wide"  # Creates separate columns for each variable
) %>%
  rename(
    pop_density = pop_densityE,  # E = estimate
    median_income = median_incomeE
  ) %>%
  select(GEOID, pop_density, median_income)

# 2. Prepare EV data - count vehicles by census tract
ev_counts <- ev_data_modified %>%
  # Ensure census tract is character type
  mutate(census_tract = as.character(census_tract)) %>%
  # Count EVs per census tract
  group_by(census_tract) %>%
  summarize(EV_Count = n())

# 3. Merge the datasets
merged_data <- ev_counts %>%
  left_join(demographic_data, by = c("census_tract" = "GEOID"))

# 4. Verify the merged data structure
glimpse(merged_data)

# 5. Correlation analysis with the correct columns
cor_results <- cor(
  merged_data %>% select(EV_Count, pop_density, median_income),
  use = "complete.obs"
)

print(cor_results)

```

```{r}
# Check column names in both datasets
names(ev_data_modified)
names(demographic_data)
```

```{r}
install.packages("leaflet")
```


T7: Overlay EV adoption data with census tract data
```{r}
library(tidyverse)
library(tidycensus)
library(sf)
library(leaflet)

# 1. First ensure we have proper EV counts by census tract
ev_counts <- ev_data_modified %>%
  mutate(census_tract = as.character(census_tract)) %>%
  group_by(census_tract) %>%
  summarize(EV_Count = n())  # Count EVs per tract

# 2. Get census tract shapes with demographic data
census_shapes <- get_acs(
  geography = "tract",
  variables = "B01001_001",  # Total population
  state = "WA",
  year = 2020,
  geometry = TRUE  # Get spatial data
) %>%
  select(GEOID, geometry)

# 3. Merge EV counts with census shapes
ev_census_overlay <- census_shapes %>%
  left_join(ev_counts, by = c("GEOID" = "census_tract")) %>%
  mutate(
    EV_Count = replace_na(EV_Count, 0),  # Replace NA with 0 for visualization
    EV_Count = as.numeric(EV_Count)      # Ensure numeric type
  )

# 4. Create the map with proper data checks
# First verify we have proper data
summary(ev_census_overlay$EV_Count)

# Create color palette based on actual data range
pal <- colorNumeric(
  palette = "viridis",
  domain = ev_census_overlay$EV_Count
)

# Generate the map
leaflet(ev_census_overlay) %>%
  addTiles() %>%
  addPolygons(
    fillColor = ~pal(EV_Count),
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "Census Tract:", GEOID, "<br>",
      "EV Count:", EV_Count
    )
  ) %>%
  addLegend(
    pal = pal,
    values = ~EV_Count,
    title = "EV Count per Tract"
  )
```


```{r}
highest_county <- ev_county %>% arrange(desc(EV_Count)) %>% head(1)
lowest_county <- ev_county %>% arrange(EV_Count) %>% head(1)

highest_city <- ev_city %>% arrange(desc(EV_Count)) %>% head(1)
lowest_city <- ev_city %>% arrange(EV_Count) %>% head(1)

print(highest_county)
print(lowest_county)
print(highest_city)
print(lowest_city)

```


```{r}
# Install and load required packages
if (!require("spatialreg")) install.packages("spatialreg")
if (!require("spdep")) install.packages("spdep")  # Contains poly2nb
if (!require("sf")) install.packages("sf")
if (!require("tidyverse")) install.packages("tidyverse")

library(spatialreg)
library(spdep)
library(sf)
library(tidyverse)

# Spatial regression model setup (assuming spatial weights matrix is available)
neighbors <- poly2nb(county_shapes)
weights_matrix <- nb2listw(neighbors, style = "W", zero.policy = TRUE)

sar_model <- lagsarlm(EV_Count ~ pop_density + median_income, data=county_shapes, listw=weights_matrix)
summary(sar_model)

```

