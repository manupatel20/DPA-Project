
```{r}
library(tidycensus)
library(tidyverse)

# Define variable codes (no friendly names)
vars <- c(
  "B01003_001",  # Total Population
  "B23025_003",  # Employed Population
  "B15003_022",  # Bachelor's Degree or Higher
  "B19013_001"   # Median Household Income
)

# Fetch data (geometry included)
census_data <- get_acs(
  geography = "tract",
  variables = vars,
  state = "WA",
  year = 2020,
  geometry = TRUE,
  output = "wide"  # Automatically pivots to wide format
)

census_data_clean <- census_data %>%
  rename(
    population = B01003_001E,
    employed_population = B23025_003E,
    bachelors_or_higher = B15003_022E,
    median_income = B19013_001E
  ) %>%
  select(GEOID, NAME, population, employed_population, 
         bachelors_or_higher, median_income, geometry)

glimpse(census_data_clean)


```





```{r}
library(tidycensus)
library(tidyverse)

# Set your variable list (with meaningful names)
vars <- c(
  population = "B01003_001",
  employed_population = "B23025_003",
  bachelors_or_higher = "B15003_022",
  urban_rural_classification = "B08006_001",
  median_income = "B19013_001"
)

# Get ACS data with all variables for WA census tracts
census_data <- get_acs(
  geography = "tract",
  variables = vars,
  state = "WA",
  year = 2020,
  geometry = TRUE
)

# Check what the data looks like before pivoting
head(census_data)

# Pivot to wide format
census_data_wide <- census_data %>%
  select(GEOID, NAME, variable, estimate, geometry) %>%
  pivot_wider(names_from = variable, values_from = estimate)

# Rename columns using the `vars` vector
# Reverse the `vars` vector so you map from codes to readable names
# Rename columns using the `vars` vector
code_to_name <- setNames(names(vars), vars)

census_data_renamed <- census_data_wide %>%
  rename_with(~ code_to_name[.x], .cols = names(code_to_name))

# View final dataset
glimpse(census_data_renamed)

```












```{r}
ev_data <- read.csv("../Dataset/pre-processed-EV-dataset.csv")
```

```{r}
# Aggregate data by County
ev_county <- ev_data %>%
  group_by(county) %>%
  summarise(EV_Count = n())

# Aggregate data by City
ev_city <- ev_data %>%
  group_by(city) %>%
  summarise(EV_Count = n())

# Aggregate data by Legislative District
ev_district <- ev_data %>%
  group_by(legislative_district) %>%
  summarise(EV_Count = n())
```

```{r}
ev_district
```

```{r}
library(dplyr)
library(ggplot2)

top_counties <- ev_data %>%
  count(county, name = "EV_Count") %>%
  slice_max(EV_Count, n = 20)  # Select top 20 counties with highest EV count

ggplot(top_counties, aes(x = reorder(county, EV_Count), y = EV_Count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for better readability
  labs(title = "Top 20 Counties with Highest EV Adoption", x = "County", y = "EV Count") +
  theme_minimal()
```


```{r}
library(dplyr)
library(ggplot2)

top_cities <- ev_data %>%
  count(city, name = "EV_Count") %>%
  slice_max(EV_Count, n = 20)  # Select top 20 cities with highest EV count

ggplot(top_cities, aes(x = reorder(city, EV_Count), y = EV_Count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for better readability
  labs(title = "Top 20 Cities with Highest EV Adoption", x = "City", y = "EV Count") +
  theme_minimal()
```

```{r}
library(dplyr)
library(ggplot2)

top_ld <- ev_data %>%
  count(legislative_district, name = "EV_Count") %>%
  slice_max(EV_Count, n = 20)  # Select top 20 legislative_district with highest EV count

ggplot(top_ld, aes(x = reorder(legislative_district, EV_Count), y = EV_Count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for better readability
  labs(title = "Top 20 Cities with Highest EV Adoption", x = "City", y = "EV Count") +
  theme_minimal()
```




```{r}
########   Check data variables available in 'tidycensus'     ###########

library(tidycensus)

# Load list of variables for 2020 ACS 5-year
acs_vars <- load_variables(2020, "acs5", cache = TRUE)

# View sample
View(acs_vars)  # Opens a searchable table in RStudio
```



```{r}
library(tidyverse)
library(tidycensus)

# Set up your census API key (if not already set in your environment)
# census_api_key("your_api_key", install = TRUE)

# Extract the specified variable codes for Washington state (2020 ACS)
census_data <- get_acs(
  geography = "tract",  # Geographic level: census tracts
  variables = c(
    "B01003_001",  # Total Population
    "B23025_003",  # Civilian labor force: Employed population
    "B15003_022",  # Bachelor's degree or higher (Educational attainment)
    "B08006_001",  # Total population by urban/rural classification
    "B19013_001"   # Median household income
  ),
  state = "WA",  # Washington state
  year = 2020,   # ACS 5-year estimates for 2020
  geometry = TRUE  # Include geometry for spatial data
)

# Process the data
census_data_clean <- census_data %>%
  # Pivot the data to have variables as columns
  pivot_wider(names_from = variable, values_from = estimate) %>%
  # Rename columns for clarity (use `select` instead of `rename` here)
  select(
    GEOID, 
    population = B01003_001,
    employed_population = B23025_003,
    bachelors_or_higher = B15003_022,
    urban_rural_classification = B08006_001,
    median_income = B19013_001,
    geometry, 
    NAME
  )

# View the cleaned data
print(census_data_clean)
```




API key - c00131b3556a74bad78bbbb2d648afc4603bd046

```{r}
library(sf)
library(tidycensus)
library(stringr)

# Get Washington State county geometries
census_api_key("c00131b3556a74bad78bbbb2d648afc4603bd046")  # Set your Census API key
county_shapes <- get_acs(
  geography = "county",
  variables = "B01001_001",  # Total population (for reference)
  state = "WA",
  geometry = TRUE
)

# Step 1: Clean the county names in 'county_shapes' by removing 'County, Washington'
county_shapes <- county_shapes %>%
  mutate(NAME_clean = str_remove(NAME, " County, Washington"))

# Merge EV adoption data with county geometries
county_shapes <- county_shapes %>%
  left_join(ev_county, by = c("NAME_clean" = "county"))

# Step 1: Calculate centroids for each county (for positioning the text labels)
county_shapes <- county_shapes %>%
  mutate(centroid = st_centroid(geometry))

# Step 2: Extract the x and y coordinates of the centroids for text placement
county_shapes <- county_shapes %>%
  mutate(centroid_x = st_coordinates(centroid)[, 1],
         centroid_y = st_coordinates(centroid)[, 2])

# Step 3: Plot choropleth map with labels
ggplot(county_shapes) +
  geom_sf(aes(fill = EV_Count)) +
  scale_fill_gradient(low = "lightblue", high = "blue", na.value = "grey") +
  labs(title = "EV Adoption by County in Washington State", fill = "EV Count") +
  theme_minimal() +
  
  # Add EV_Count labels at the centroids of each county
  geom_text(aes(x = centroid_x, y = centroid_y, label = EV_Count), 
            size = 3,  # Adjust label size
            color = "black",  # Adjust text color
            check_overlap = TRUE)  # Prevent overlap of labels

```


```{r}
# # Install and load required packages
# install.packages(c("tidycensus", "sf"))
# library(tidycensus)
# library(sf)
# 
# # Set your Census API key (replace <API-KEY> with your actual key)
# census_api_key("c00131b3556a74bad78bbbb2d648afc4603bd046")
# 
# # Get city-level geometries for Washington State
# city_shapes <- get_acs(
#   geography = "place",  # 'place' refers to cities/towns
#   variables = "B01001_001",  # Total population (for reference)
#   state = "WA",  # Washington State
#   year = 2020,  # ACS Year
#   geometry = TRUE  # Include spatial geometries
# )
# 
# # View the structure of city shapes
# # print(city_shapes)
# 
# # Plot city geometries (basic visualization)
# plot(city_shapes["geometry"])
# 
# ggplot() +
#   # Add Washington state border (outline)
#   geom_sf(data = state_shapes, fill = NA, color = "black", size = 1) +
#   
#   # Add cities with EV counts
#   geom_sf(data = city_shapes, aes(fill = EV_Count)) +
#   
#   # Color scale for EV counts
#   scale_fill_viridis_c(option = "magma", na.value = "grey") +
#   
#   # Labels and title
#   labs(title = "EV Adoption by City in Washington State", fill = "EV Count") +
#   
#   # Minimal theme for clarity
#   theme_minimal()

```


#### NOT ADDING ANY VALUE #####
```{r}
library(dplyr)
library(ggplot2)
library(stringr)


city_shapes <- get_acs(
  geography = "place",  # 'place' refers to cities/towns
  variables = "B01001_001",  # Total population (for reference)
  state = "WA",  # Washington State
  year = 2020,  # ACS Year
  geometry = TRUE  # Include spatial geometries
)

city_shapes <- city_shapes %>%
  mutate(
    NAME_clean = str_remove(NAME, " (town|city|CDP), Washington")  # Remove suffixes
  )

# Merge EV adoption data with city geometries
city_shapes <- city_shapes %>%
  left_join(ev_city, by = c("NAME_clean" = "city"))

# Plot choropleth map for cities
ggplot(city_shapes) +
  geom_sf(aes(fill = EV_Count)) +
  scale_fill_viridis_c(option = "magma", na.value = "grey") +
  labs(title = "EV Adoption by City in Washington State", fill = "EV Count") +
  theme_minimal()


# Step 1: Calculate centroids for each county (for positioning the text labels)
city_shapes <- city_shapes %>%
  mutate(centroid = st_centroid(geometry))

# Step 2: Extract the x and y coordinates of the centroids for text placement
city_shapes <- city_shapes %>%
  mutate(centroid_x = st_coordinates(centroid)[, 1],
         centroid_y = st_coordinates(centroid)[, 2])

# Step 3: Plot choropleth map with labels
ggplot(city_shapes) +
  geom_sf(aes(fill = EV_Count)) +
  scale_fill_gradient(low = "lightblue", high = "blue", na.value = "grey") +
  labs(title = "EV Adoption by City in Washington State", fill = "EV Count") +
  theme_minimal() +
  
  # Add EV_Count labels at the centroids of each county
  geom_text(aes(x = centroid_x, y = centroid_y, label = EV_Count), 
            size = 3,  # Adjust label size
            color = "black",  # Adjust text color
            check_overlap = TRUE)

```

```{r}
ev_data_modified_census_tract <- ev_data %>%
  mutate(census_tract = as.character(census_tract))
```



**T6: Analyze correlations between EV adoption and geographic factors**
```{r}
library(tidyverse)
library(tidycensus)

# 1. Load and prepare demographic data
demographic_data <- get_acs(
  geography = "tract",
  variables = c(
    pop_density = "B01001_001",  # Total population (proxy for density)
    median_income = "B19013_001"  # Median household income
  ),
  state = "WA",
  year = 2020,
  geometry = TRUE,
  output = "wide"  # Creates separate columns for each variable
) %>%
  rename(
    pop_density = pop_densityE,  # E = estimate
    median_income = median_incomeE
  ) %>%
  select(GEOID, pop_density, median_income, NAME, geometry)

# 2. Prepare EV data - count vehicles by census tract
ev_counts <- ev_data_modified_census_tract %>%
  # Ensure census tract is character type
  mutate(census_tract = as.character(census_tract)) %>%
  # Count EVs per census tract
  group_by(census_tract) %>%
  summarize(EV_Count = n())

# 3. Merge the datasets
merged_data <- ev_counts %>%
  left_join(demographic_data, by = c("census_tract" = "GEOID"))

# 4. Verify the merged data structure
# glimpse(merged_data)

# 5. Correlation analysis with the correct columns
cor_results <- cor(
  merged_data %>% select(EV_Count, pop_density, median_income),
  use = "complete.obs"
)

print(cor_results)

```

```{r}
# Check column names in both datasets
names(ev_data_modified_census_tract)
names(demographic_data)
```

```{r}
install.packages("leaflet")
```


T7: Overlay EV adoption data with census tract data
```{r}
library(tidyverse)
library(tidycensus)
library(sf)
library(leaflet)

# 1. First ensure we have proper EV counts by census tract
ev_counts <- ev_data_modified_census_tract %>%
  mutate(census_tract = as.character(census_tract)) %>%
  group_by(census_tract) %>%
  summarize(EV_Count = n())  # Count EVs per tract

# 2. Get census tract shapes with demographic data
census_shapes <- get_acs(
  geography = "tract",
  variables = "B01001_001",  # Total population
  state = "WA",
  year = 2020,
  geometry = TRUE  # Get spatial data
) %>%
  select(GEOID, geometry, NAME)  # Add NAME to get census tract names

# 3. Merge EV counts with census shapes
ev_census_overlay <- census_shapes %>%
  left_join(ev_counts, by = c("GEOID" = "census_tract")) %>%
  mutate(
    EV_Count = replace_na(EV_Count, 0),  # Replace NA with 0 for visualization
    EV_Count = as.numeric(EV_Count)      # Ensure numeric type
  )

# 4. Create the map with proper data checks
summary(ev_census_overlay$EV_Count)

# Create color palette based on actual data range
pal <- colorNumeric(
  palette = "viridis",
  domain = ev_census_overlay$EV_Count
)

top_10 <- ev_census_overlay %>%
  arrange(desc(EV_Count)) %>%
  slice_head(n = 10)

bottom_10 <- ev_census_overlay %>%
  filter(EV_Count > 0 | is.na(EV_Count) == FALSE) %>%  # Optional: remove NA
  arrange(EV_Count) %>%
  distinct(EV_Count, .keep_all = TRUE) %>%  # Keep only one row per value
  slice_head(n = 10)

# Transform CRS
ev_census_overlay <- st_transform(ev_census_overlay, crs = 4326)
ev_census_overlay <- ev_census_overlay %>%
  mutate(
    fill_color = case_when(
      GEOID %in% top_10$GEOID ~ "green",
      GEOID %in% bottom_10$GEOID ~ "red",
      TRUE ~ pal(EV_Count)
    )
  )

# Generate the map
leaflet(ev_census_overlay %>% st_transform(4326)) %>%
  addTiles() %>%
  addPolygons(
    fillColor = ~fill_color,
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",  # Display the tract name
      "<strong>EV Count:</strong>", EV_Count
    )
  ) %>%
  addLegend(
    pal = pal,
    values = ~EV_Count,
    title = "EV Count per Tract",
    position = "bottomright"
  ) %>%
  addLegend(
    colors = c("green", "red"),
    labels = c("Top 10 EV Tracts", "Bottom 10 EV Tracts"),
    title = "Highlighted Tracts",
    position = "bottomleft"
  )
```


```{r}
library(tidyverse)
library(tidycensus)
library(sf)
library(leaflet)

# 1. First ensure we have proper EV counts by census tract
ev_counts <- ev_data_modified_census_tract %>%
  group_by(census_tract) %>%
  summarize(EV_Count = n())  # Count EVs per tract

# 2. Get census tract demographic data (Population and Median Income)
census_data <- get_acs(
  geography = "tract",
  variables = c(population = "B01001_001", median_income = "B19013_001"),  # Total population and median income
  state = "WA",
  year = 2020,
  geometry = TRUE  # Get spatial data
) %>%
  select(GEOID, population = estimate, median_income = estimate, geometry, NAME)  # Add NAME to get census tract names

# 3. Merge EV counts with census shapes and demographic data
ev_census_overlay <- census_data %>%
  left_join(ev_counts, by = c("GEOID" = "census_tract")) %>%
  mutate(
    EV_Count = replace_na(EV_Count, 0),  # Replace NA with 0 for visualization
    EV_Count = as.numeric(EV_Count)      # Ensure numeric type
  )

# 4. Summary check to ensure EV data merged correctly
summary(ev_census_overlay$EV_Count)
summary(ev_census_overlay$median_income)
summary(ev_census_overlay$population)

# 5. Create color palettes for Population and Income
pop_pal <- colorNumeric(
  palette = "Blues", 
  domain = ev_census_overlay$population
)

income_pal <- colorNumeric(
  palette = "YlOrRd", 
  domain = ev_census_overlay$median_income
)

# 6. Create the map with both Population and Income Data

leaflet(ev_census_overlay %>% st_transform(4326)) %>%
  addTiles() %>%
  addPolygons(
    fillColor = ~pop_pal(population),  # Color by population
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",  # Display the tract name
      "<strong>EV Count:</strong>", EV_Count, "<br>",
      "<strong>Population:</strong>", population, "<br>",
      "<strong>Median Income:</strong>", median_income
    )
  ) %>%
  addLegend(
    pal = pop_pal,
    values = ~population,
    title = "Population per Tract",
    position = "bottomright"
  ) %>%
  addLegend(
    pal = income_pal,
    values = ~median_income,
    title = "Median Income per Tract",
    position = "bottomleft"
  )
```


```{r}
library(tidyverse)
library(tidycensus)
library(sf)
library(leaflet)

# 1. First ensure we have proper EV counts by census tract
ev_counts <- ev_data_modified_census_tract %>%
  group_by(census_tract) %>%
  summarize(EV_Count = n())  # Count EVs per tract

# 2. Get census tract demographic data (Population and Median Income)
census_data <- get_acs(
  geography = "tract",
  variables = c(population = "B01001_001", median_income = "B19013_001"),  # Total population and median income
  state = "WA",
  year = 2020,
  geometry = TRUE  # Get spatial data
) %>%
  select(GEOID, population = estimate, median_income = estimate, geometry, NAME)  # Add NAME to get census tract names

# 3. Merge EV counts with census shapes and demographic data
ev_census_overlay <- census_data %>%
  left_join(ev_counts, by = c("GEOID" = "census_tract")) %>%
  mutate(
    EV_Count = replace_na(EV_Count, 0),  # Replace NA with 0 for visualization
    EV_Count = as.numeric(EV_Count)      # Ensure numeric type
  )

# 4. Check for any NA or missing values in the dataset (this will help diagnose potential issues)
summary(ev_census_overlay$EV_Count)
summary(ev_census_overlay$median_income)
summary(ev_census_overlay$population)

# 5. Create color palettes for Population and Income
pop_pal <- colorNumeric(
  palette = "Blues", 
  domain = ev_census_overlay$population
)

income_pal <- colorNumeric(
  palette = "YlOrRd", 
  domain = ev_census_overlay$median_income
)

# 6. Create the map with both Population and Income Data
leaflet(ev_census_overlay %>% st_transform(4326)) %>%
  addTiles() %>%
  addPolygons(
    fillColor = ~income_pal(median_income),  # Color by median income
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",  # Display the tract name
      "<strong>EV Count:</strong>", EV_Count, "<br>",
      "<strong>Population:</strong>", population, "<br>",
      "<strong>Median Income:</strong>", median_income
    )
  ) %>%
  addLegend(
    pal = income_pal,
    values = ~median_income,
    title = "Median Income per Tract",
    position = "bottomleft"
  )
```




```{r}
library(RColorBrewer)
library(tidyverse)
library(tidycensus)
library(sf)
library(leaflet)

# 1. First ensure we have proper EV counts by census tract
ev_counts <- ev_data_modified_census_tract %>%
  group_by(census_tract) %>%
  summarize(EV_Count = n())  # Count EVs per tract

# 2. Get census tract demographic data (Population and Median Income)
census_data <- get_acs(
  geography = "tract",
  variables = c(population = "B01001_001", median_income = "B19013_001"),  # Total population and median income
  state = "WA",
  year = 2020,
  geometry = TRUE  # Get spatial data
) %>%
  select(GEOID, population = estimate, median_income = estimate, geometry, NAME)  # Add NAME to get census tract names

# 3. Merge EV counts with census shapes and demographic data
ev_census_overlay <- census_data %>%
  left_join(ev_counts, by = c("GEOID" = "census_tract")) %>%
  mutate(
    EV_Count = replace_na(EV_Count, 0),  # Replace NA with 0 for visualization
    EV_Count = as.numeric(EV_Count)      # Ensure numeric type
  )

# 4. Summary check to ensure EV data merged correctly
summary(ev_census_overlay$EV_Count)
summary(ev_census_overlay$median_income)
summary(ev_census_overlay$population)

# 5. Create color palettes for Population and Income
ev_pal <- colorNumeric(
  palette = "Blues", 
  domain = ev_census_overlay$EV_Count
)


pop_pal <- colorNumeric(
  palette = brewer.pal(9, "YlGn"), 
  domain = ev_census_overlay$population
)

income_pal <- colorNumeric(
  palette = "YlOrRd", 
  domain = ev_census_overlay$median_income
)

# Create color palettes for population and median income
# pop_pal <- colorNumeric(palette = "YlOrRd", domain = ev_census_overlay$pop_density)
# income_pal <- colorNumeric(palette = "Blues", domain = ev_census_overlay$median_income)

# Transform data to WGS84 projection (required by Leaflet)
ev_census_sf <- ev_census_overlay %>% st_transform(4326)

# # Generate the map with layer controls
# leaflet(ev_census_sf) %>%
#   addTiles() %>%
#   # Add population layer (hidden by default)
#   addPolygons(
#     fillColor = ~pop_pal(population),
#     color = "#444444",
#     weight = 1,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = 0.7,
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>EV Count:</strong>", EV_Count, "<br>",
#       "<strong>Population:</strong>", population, "<br>",
#       "<strong>Median Income:</strong>", median_income
#     ),
#     group = "Population"  # Assign to a named group
#   ) %>%
#   # Add income layer (hidden by default)
#   addPolygons(
#     fillColor = ~income_pal(median_income),
#     color = "#444444",
#     weight = 1,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = 0.7,
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>EV Count:</strong>", EV_Count, "<br>",
#       "<strong>Population:</strong>", population, "<br>",
#       "<strong>Median Income:</strong>", median_income
#     ),
#     group = "Median Income"  # Assign to a named group
#   ) %>%
#   # Add legends for both layers
#   addLegend(
#     pal = pop_pal,
#     values = ~population,
#     title = "Population",
#     position = "bottomleft",
#     group = "Population"
#   ) %>%
#   addLegend(
#     pal = income_pal,
#     values = ~median_income,
#     title = "Median Income",
#     position = "bottomright",
#     group = "Median Income"
#   ) %>%
#   # Add layer controls to toggle between visualizations
#   addLayersControl(
#     baseGroups = c("Population", "Median Income"),
#     options = layersControlOptions(collapsed = FALSE)
#   )

#########         2          #####
# Generate the map with an additional layer for EV Count
# leaflet(ev_census_sf) %>%
#   addTiles() %>%
#   
#   # Add EV Count layer
#   addPolygons(
#     fillColor = ~ev_pal(EV_Count),
#     color = "#444444",
#     weight = 1,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = 0.7,
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>EV Count:</strong>", EV_Count
#     ),
#     group = "EV Count"   # Assign this layer to the "EV Count" group
#   ) %>%
#   
#   # Highlight top and bottom tracts in separate colors
#   addPolygons(
#     fillColor = ~case_when(
#       GEOID %in% top_10$GEOID ~ "green",
#       GEOID %in% bottom_10$GEOID ~ "red",
#       TRUE ~ NA_character_
#     ),
#     color = "#444444",
#     weight = 1,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = ~ifelse(GEOID %in% c(top_10$GEOID, bottom_10$GEOID), .9, .0),
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>EV Count:</strong>", EV_Count
#     ),
#     group = "Highlighted Tracts"   # Assign this layer to the "Highlighted Tracts" group
#   ) %>%
#   
#   # Add legends for both layers
#   addLegend(
#     pal = ev_pal,
#     values = ~EV_Count,
#     title = "EV Count per Tract",
#     position = "bottomright",
#     group = "EV Count"
#   ) %>%
#   
#   addLegend(
#     colors = c("green", "red"),
#     labels = c("Top EV Tracts", "Bottom EV Tracts"),
#     title = "Highlighted Tracts",
#     position = "bottomleft",
#     group = "Highlighted Tracts"
#   ) %>%
#   
#   # Add layer controls to toggle between layers
#   addLayersControl(
#     overlayGroups = c("EV Count", "Highlighted Tracts"),
#     options = layersControlOptions(collapsed = FALSE)
#   )

##########.   3      #######
# Generate the map with layer controls for Population, Income, and EV Count
leaflet(ev_census_overlay) %>%
  addTiles() %>%

  # Add Population Layer
  addPolygons(
    fillColor = ~pop_pal(population),
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",
      "<strong>Population:</strong>", population
    ),
    group = "Population"
  ) %>%

  # Add Median Income Layer
  addPolygons(
    fillColor = ~income_pal(median_income),
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",
      "<strong>Median Income:</strong>", median_income
    ),
    group = "Median Income"
  ) %>%

  # Add EV Count Layer
  addPolygons(
    fillColor = ~ev_pal(EV_Count),
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",
      "<strong>EV Count:</strong>", EV_Count
    ),
    group = "EV Count"
  ) %>%

  # Add Legends for Each Layer
  addLegend(
    pal = pop_pal,
    values = ~population,
    title = "Population",
    position = "bottomleft",
    group = "Population"
  ) %>%
  
  addLegend(
    pal = income_pal,
    values = ~median_income,
    title = "Median Income",
    position = "bottomright",
    group = "Median Income"
  ) %>%

  addLegend(
    pal = ev_pal,
    values = ~EV_Count,
    title = "EV Count per Tract",
    position = "topright",
    group = "EV Count"
  ) %>%

  # Add Layer Controls to Toggle Between Layers
  addLayersControl(
    baseGroups = c("Population", "Median Income", "EV Count"),
    options = layersControlOptions(collapsed = FALSE)
  )
```


```{r}
# library(tidyverse)
# library(tidycensus)
# library(sf)
# library(leaflet)
# 
# # 1. Ensure proper EV counts by census tract
# ev_counts <- ev_data_modified_census_tract %>%
#   mutate(census_tract = as.character(census_tract)) %>%
#   group_by(census_tract) %>%
#   summarize(EV_Count = n())  # Count EVs per tract
# 
# # 2. Get census tract shapes with demographic data
# census_data <- get_acs(
#   geography = "tract",
#   variables = c(population = "B01001_001", median_income = "B19013_001"),  # Total population and median income
#   state = "WA",
#   year = 2020,
#   geometry = TRUE  # Get spatial data
# ) %>%
#   select(GEOID, population = estimate, median_income = estimate, geometry, NAME)
# 
# # 3. Merge EV counts with census shapes and demographic data
# ev_census_overlay <- census_data %>%
#   left_join(ev_counts, by = c("GEOID" = "census_tract")) %>%
#   mutate(
#     EV_Count = replace_na(EV_Count, 0),  # Replace NA with 0 for visualization
#     EV_Count = as.numeric(EV_Count)      # Ensure numeric type
#   )
# 
# # Transform CRS for Leaflet compatibility
# ev_census_overlay <- st_transform(ev_census_overlay, crs = 4326)
# 
# # 4. Calculate Intersection of All Three Layers
# # Filter out regions where any of the attributes is missing or zero
# intersection_layer <- ev_census_overlay %>%
#   filter(!is.na(population) & population > 0,
#          !is.na(median_income) & median_income > 0,
#          !is.na(EV_Count) & EV_Count > 0)
# 
# # Create a combined score for visualization (optional)
# intersection_layer <- intersection_layer %>%
#   mutate(
#     combined_score = (population / max(population)) +
#                      (median_income / max(median_income)) +
#                      (EV_Count / max(EV_Count))
#   )
# 
# top_10_counties <- intersection_layer %>%
#   arrange(desc(combined_score)) %>%
#   slice_head(n = 10)
# 
# bottom_10_counties <- intersection_layer %>%
#   filter(combined_score > 0) %>%  # Ensure we don't include zeros
#   arrange(combined_score) %>%
#   slice_head(n = 10)
# 
# # Add a column to identify if a county is in top 10, bottom 10, or neither
# intersection_layer <- intersection_layer %>%
#   mutate(highlight_category = case_when(
#     GEOID %in% top_10_counties$GEOID ~ "Top 10",
#     GEOID %in% bottom_10_counties$GEOID ~ "Bottom 10",
#     TRUE ~ "Other"
#   ))
# 
# highlight_pal <- colorFactor(
#   palette = c("green", "red", "lightgray"),
#   domain = c("Top 10", "Bottom 10", "Other")
# )
# 
# # Create color palette for the intersection layer
# intersection_pal <- colorNumeric(
#   palette = "PuBu", 
#   domain = intersection_layer$combined_score
# )
# 
# # Generate the map for the intersection layer
# # leaflet(intersection_layer) %>%
# #   addTiles() %>%
# #   
# #   # Add Intersection Layer
# #   addPolygons(
# #     fillColor = ~intersection_pal(combined_score),
# #     color = "#444444",
# #     weight = 1,
# #     smoothFactor = 0.5,
# #     opacity = 1,
# #     fillOpacity = 0.7,
# #     popup = ~paste(
# #       "<strong>Census Tract:</strong>", NAME, "<br>",
# #       "<strong>Population:</strong>", population, "<br>",
# #       "<strong>Median Income:</strong>", median_income, "<br>",
# #       "<strong>EV Count:</strong>", EV_Count, "<br>",
# #       "<strong>Combined Score:</strong>", combined_score
# #     )
# #   ) %>%
# #   
# #   # Add Legend for Intersection Layer
# #   addLegend(
# #     pal = intersection_pal,
# #     values = ~combined_score,
# #     title = "Intersection of EV Count, Median Income and Population",
# #     position = "bottomright"
# #   )
# 
# # Generate the map with both the intersection layer and highlighted counties
# leaflet(intersection_layer) %>%
#   addTiles() %>%
#   
#   # Add Intersection Layer (keep your original layer)
#   addPolygons(
#     fillColor = ~intersection_pal(combined_score),
#     color = "#444444",
#     weight = 1,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = 0.7,
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>Population:</strong>", population, "<br>",
#       "<strong>Median Income:</strong>", median_income, "<br>",
#       "<strong>EV Count:</strong>", EV_Count, "<br>",
#       "<strong>Combined Score:</strong>", round(combined_score, 3)
#     ),
#     group = "All Tracts"
#   ) %>%
#   
#   # Add Highlighted Counties Layer (on top)
#   addPolygons(
#     data = intersection_layer %>% filter(highlight_category != "Other"),
#     fillColor = ~highlight_pal(highlight_category),
#     color = "black",
#     weight = 2,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = 0.5,
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>Population:</strong>", population, "<br>",
#       "<strong>Median Income:</strong>", median_income, "<br>",
#       "<strong>EV Count:</strong>", EV_Count, "<br>",
#       "<strong>Combined Score:</strong>", round(combined_score, 3),
#       "<strong>Category:</strong>", highlight_category
#     ),
#     group = "Highlighted Tracts"
#   ) %>%
#   
#   # Add Legend for Intersection Layer
#   addLegend(
#     pal = intersection_pal,
#     values = ~combined_score,
#     title = "Combined Score",
#     position = "bottomright"
#   ) %>%
#   
#   # Add Legend for Highlighted Counties
#   addLegend(
#     colors = c("green", "red"),
#     labels = c("Top 10 Tracts", "Bottom 10 Tracts"),
#     title = "Highlighted Tracts",
#     position = "bottomleft"
#   ) %>%
#   
#   # Add Layer Controls
#   addLayersControl(
#     overlayGroups = c("All Tracts", "Highlighted Tracts"),
#     options = layersControlOptions(collapsed = FALSE)
#   )


library(tidyverse)
library(tidycensus)
library(sf)
library(leaflet)

# 1. Ensure proper EV counts by census tract
ev_counts <- ev_data_modified_census_tract %>%
  group_by(census_tract) %>%
  summarize(EV_Count = n())  # Count EVs per tract

# 2. Get census tract shapes with demographic data
# 2. Get census tract shapes with demographic data
census_data <- get_acs(
  geography = "tract",
  variables = c("B01001_001", "B19013_001"),  # Remove custom names here
  state = "WA",
  year = 2020,
  geometry = TRUE
) %>%
  # Pivot wider using original Census IDs
  pivot_wider(
    names_from = variable, 
    values_from = estimate
  ) %>%
  # Rename columns after pivoting
  rename(
    population = B01001_001,
    median_income = B19013_001
  ) %>%
  select(GEOID, population, median_income, geometry, NAME)




# 3. Merge EV counts with census shapes and demographic data
ev_census_overlay <- census_data %>%
  left_join(ev_counts, by = c("GEOID" = "census_tract")) %>%
  mutate(
    EV_Count = replace_na(EV_Count, 0),  # Replace NA with 0 for visualization
    EV_Count = as.numeric(EV_Count),      # Ensure numeric type
    population = replace_na(population, 0),  # Replace NA with 0 for visualization
    median_income = replace_na(median_income, 0),  # Replace NA with 0 for visualization
  )

# Transform CRS for Leaflet compatibility
ev_census_overlay <- st_transform(ev_census_overlay, crs = 4326)

# 4. Calculate Intersection of All Three Layers
# Filter out regions where any of the attributes is missing or zero
intersection_layer <- ev_census_overlay %>%
  filter(population > 0, median_income > 0, EV_Count > 0)

# Create a combined score for visualization
intersection_layer <- intersection_layer %>%
  mutate(
    combined_score = (population / max(population, na.rm = TRUE)) +
                     (median_income / max(median_income, na.rm = TRUE)) +
                     (EV_Count / max(EV_Count, na.rm = TRUE))
  )

# Identify top 10 and bottom 10 tracts based on combined score
top_10_counties <- intersection_layer %>%
  arrange(desc(combined_score)) %>%
  slice_head(n = 10)

bottom_10_counties <- intersection_layer %>%
  filter(combined_score > 0) %>%  # Ensure we don't include zeros
  arrange(combined_score) %>%
  slice_head(n = 10)


# 7. Add highlight category
intersection_layer <- intersection_layer %>%
  mutate(highlight_category = case_when(
    GEOID %in% top_10_counties$GEOID ~ "Top 10",
    GEOID %in% bottom_10_counties$GEOID ~ "Bottom 10",
    TRUE ~ "Other"
  ))

# Define color palettes
# Top 10 will be green, Bottom 10 will be red, Others will use the PuBu gradient
highlight_pal <- colorFactor(
  palette = c("green", "red", "gray"),  # Make "Other" gray to show underlying color
  domain = c("Top 10", "Bottom 10", "Other")
)

# Create color palette for the intersection layer (for all tracts)
intersection_pal <- colorNumeric(
  palette = "PuBu", 
  domain = intersection_layer$combined_score
)

# # Generate the map with both the intersection layer and highlighted counties
# leaflet(intersection_layer) %>%
#   addTiles() %>%
#   
#   # Add base layer with all tracts colored by combined score
#   addPolygons(
#     fillColor = ~intersection_pal(combined_score),
#     color = "#444444",
#     weight = 1,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = 0.7,
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>Population:</strong>", population, "<br>",
#       "<strong>Median Income:</strong>", median_income, "<br>",
#       "<strong>EV Count:</strong>", EV_Count, "<br>",
#       "<strong>Combined Score:</strong>", round(combined_score, 3)
#     ),
#     group = "All Tracts"
#   ) %>%
#   
#   # Add highlight layer just for top and bottom tracts
#   addPolygons(
#     data = intersection_layer %>% filter(highlight_category != "Other"),
#     fillColor = ~highlight_pal(highlight_category),  # Green for top 10, red for bottom 10
#     color = "black",
#     weight = 2,
#     smoothFactor = 0.5,
#     opacity = 1,
#     fillOpacity = 0.7,
#     popup = ~paste(
#       "<strong>Census Tract:</strong>", NAME, "<br>",
#       "<strong>Population:</strong>", population, "<br>",
#       "<strong>Median Income:</strong>", median_income, "<br>",
#       "<strong>EV Count:</strong>", EV_Count, "<br>",
#       "<strong>Combined Score:</strong>", round(combined_score, 3),
#       "<strong>Category:</strong>", highlight_category
#     ),
#     group = "Highlighted Tracts"
#   ) %>%
#   
#   # Add Legend for Intersection Layer
#   addLegend(
#     pal = intersection_pal,
#     values = ~combined_score,
#     title = "Combined Score",
#     position = "bottomright"
#   ) %>%
#   
#   # Add Legend for Highlighted Counties
#   addLegend(
#     colors = c("green", "red", "gray"),
#     labels = c("Top 10 Tracts", "Bottom 10 Tracts", "NA"),
#     title = "Highlighted Tracts",
#     position = "bottomleft"
#   ) %>%
#   
#   # Add Layer Controls
#   addLayersControl(
#     overlayGroups = c("All Tracts", "Highlighted Tracts"),
#     options = layersControlOptions(collapsed = FALSE)
#   )

# 9. Generate the map
leaflet(intersection_layer) %>%
  addTiles() %>%
  
  addPolygons(
    fillColor = ~intersection_pal(combined_score),
    color = "#444444",
    weight = 1,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",
      "<strong>Population:</strong>", population, "<br>",
      "<strong>Median Income:</strong>", median_income, "<br>",
      "<strong>EV Count:</strong>", EV_Count, "<br>",
      "<strong>Combined Score:</strong>", round(combined_score, 3)
    ),
    group = "All Tracts"
  ) %>%
  
  addPolygons(
    data = intersection_layer %>% filter(highlight_category != "Other"),
    fillColor = ~highlight_pal(highlight_category),
    color = "black",
    weight = 2,
    smoothFactor = 0.5,
    opacity = 1,
    fillOpacity = 0.7,
    popup = ~paste(
      "<strong>Census Tract:</strong>", NAME, "<br>",
      "<strong>Population:</strong>", population, "<br>",
      "<strong>Median Income:</strong>", median_income, "<br>",
      "<strong>EV Count:</strong>", EV_Count, "<br>",
      "<strong>Combined Score:</strong>", round(combined_score, 3),
      "<strong>Category:</strong>", highlight_category
    ),
    group = "Highlighted Tracts"
  ) %>%
  
  addLegend(
    pal = intersection_pal,
    values = ~combined_score,
    title = "Combined Score",
    position = "bottomright"
  ) %>%
  
  addLegend(
    colors = c("green", "red", "gray"),
    labels = c("Top 10 Tracts", "Bottom 10 Tracts", "NA"),
    title = "Highlighted Tracts",
    position = "bottomleft"
  ) %>%
  
  addLayersControl(
    overlayGroups = c("All Tracts", "Highlighted Tracts"),
    options = layersControlOptions(collapsed = FALSE)
  )

```




```{r}
highest_county <- ev_county %>% arrange(desc(EV_Count)) %>% head(1)
lowest_county <- ev_county %>% arrange(EV_Count) %>% head(1)

highest_city <- ev_city %>% arrange(desc(EV_Count)) %>% head(1)
lowest_city <- ev_city %>% arrange(EV_Count) %>% head(1)

cat("Highest county:", highest_county$county, "-", highest_county$EV_Count, "\n",
    "Lowest County:", lowest_county$county, "-", lowest_county$EV_Count, "\n",
    "Highest City:", highest_city$city, "-", highest_city$EV_Count, "\n",
    "Lowest City:", lowest_city$city, "-", lowest_city$EV_Count, "\n")


# print(highest_city)
```

```{r}
library(spatialreg)

# Spatial regression model setup (assuming spatial weights matrix is available)
neighbors <- poly2nb(county_shapes)
weights_matrix <- nb2listw(neighbors)

sar_model <- lagsarlm(EV_Count ~ pop_density + median_income, data=county_shapes, listw=weights_matrix)
summary(sar_model)

```


